//==================================================================================
// Copyright (c) 2013-2016 , Advanced Micro Devices, Inc.  All rights reserved.
//
/// \author AMD Developer Tools Team
/// \file CpuProfileDataTranslation.h
/// \brief CPU profile data translation interface.
/// \note This API is only valid for \ref sampling profile data generated by
///       the \ref CpuProfileControl.h.  Older profile data may ignore the specified intervals.
///
//==================================================================================
// $Id: //devtools/main/CodeXL/Components/CpuProfiling/Backend/AMDTCpuProfilingTranslation/inc/CpuProfileDataTranslation.h#7 $
// Last checkin:   $DateTime: 2016/04/14 01:44:54 $
// Last edited by: $Author:  AMD Developer Tools Team
// Change list:    $Change: 569055 $
//=====================================================================

/** There are two forms of profile data, the raw data in files with a ".prd"
    extension and aggregated data like CodeAnalyst uses.

    To use these functions, you must start with either \ref fnOpenProfile or
    \ref fnOpenAggregatedProfile.  When you are finished, you must call
    \ref fnCloseProfile to free the file handles.

    When using the same ReaderHandle, the code is thread safe.

    There are five groups of functions: \ref datafiles, \ref timemarks, \ref
    datasets, \ref rules, and \ref data.  Rules will filter the data returned
    by the queries.

    \defgroup datafiles Data Files
    These functions handle reading profile data files.

    Raw profile data files have a ".prd" extension and should be opened with
    \ref fnOpenProfile.  Aggregate profile data files created by CodeAnalyst
    have a ".tbp" or ".ebp" extension and should be opened with \ref
    fnOpenAggregatedProfile.

    A profile data file must be opened to generate a reader handle, which will
    be used in all other interactions.  When the reader handle is no longer
    useful, it should be disposed of with \ref fnCloseProfile.

    \defgroup timemarks Time Marks
    A way to specify intervals in raw profile data files.

    Time marks allow you to specify intervals of interest to a data set.  Time
    marks are synchronized to a particular node, so any useful marks should be
    generated on the same node during the profile, possibly with the API
    function \ref fnGetCurrentTimeMark.

    Time marks are only useful to non-aggregated profile data files opened with
    \ref fnOpenProfile.

    \defgroup datasets Data Sets
    A collection of samples within specified intervals.

    A single profile may have multiple data sets, each made of multiple
    intervals of interest.  An aggregated profile data file only has one
    data set available

    A data set may have multiple contiguous or non-contiguous intervals.  If
    the intervals overlap, the data will only be counted once.  If \ref
    fnOpenProfile was used to open a .prd file, the default data set has the
    same name as the .prd file and contains the entire [start, end] interval.

    No data will be available before \ref fnAggregateDataSets aggregates the
    data to the sets, if \ref fnOpenProfile was used.

    The default data set name is NULL.  This covers the entire profile interval.

    The expected use would be to open the profile data file with \ref
    fnOpenProfile, create desired data sets with \ref fnAddDataSet, then call
    \ref fnAggregateDataSets to aggregate the data from the data file into the
    sets.

    \defgroup rules Data Rules
    A way to show only part of the data set.

    This will let you filter the displayed data.  Setting the same rule twice
    will overwrite the previous setting.  The filters apply to all \ref data.

    The rules affect both the aggregation of data and the data returned.  The
    best way to do this would be to reset the rules for the aggregation and
    only set the rules for the data queries

    The expected use would be to open the profile data file with \ref
    fnOpenProfile, create desired data sets with \ref fnAddDataSet, then call
    \ref fnAggregateDataSets to aggregate the data from the data file into the
    sets, set any of the rules, and then retrieve the data.
    Alternately, you could open an aggregated data file with \ref
    fnOpenAggregatedProfile, then set the rules, and finally retrieve the data.

    \defgroup data Data Queries
    Retrieves the information contained within a data set.

    The functions which return data need the data to be appropriate.  If \ref
    fnOpenProfile was used, \ref fnAggregateDataSets needs to be called before
    these functions will return valid data.  If you do not specify the data set
    name, the default data set will be used.

    The expected use would be to open the profile data file with \ref
    fnOpenProfile, create desired data sets with \ref fnAddDataSet, then call
    \ref fnAggregateDataSets to aggregate the data from the data file into the
    sets, set any rules, and then retrieve the data with the queries.
    Alternately, you could open an aggregated data file with \ref
    fnOpenAggregatedProfile, set any rules, and finally retrieve the data.
*/

#ifndef _CPUPROFILEDATATRANSLATION_H_
#define _CPUPROFILEDATATRANSLATION_H_

#include <AMDTOSWrappers/Include/osFilePath.h>
#include "CpuProfilingTranslationDLLBuild.h"
#include "CPA_TIME.h"


class apProfileProgressEvent;

typedef void (*PfnProgressBarCallback)(apProfileProgressEvent& progressEvent);


/****************************************************************************/

/** \typedef ReaderHandle
    \brief A handle to identify which profiles were opened.
    \ingroup datafiles

    The handle is necessary for all functions related to retrieving data from
    the opened profiles.  The two functions that will generate a new valid
    ReaderHandle are \ref fnOpenProfile and \ref fnOpenAggregatedProfile.
*/
typedef void ReaderHandle;

/** This function will open a raw profile data file.

    This function supports the following profile input:
    1. CodeAnalyst profile data with ".prd" file extension
    3. CodeAnalyst profile data with ".tbp" or ".ebp" file extension
    2. CodeAnalyst profile data with ".caperf" file extension (Linux only)
    5. OProfile samples directory (/var/lib/oprofile/samples) (Linux only)
    4. Linux Perf output file "perf.data" (Linux only)
    6. OProfile XML data file from opreport (Linux only)

    \ingroup datafiles
    @param[in] pPath The profile data file or directory of interest
    @param[out] pReaderHandle The handle to use for retrieving the data
    \return The success of opening the profile
    \retval S_OK Success
    \retval E_INVALIDARG either pPath or pReaderHandle is not a valid
    pointer
    \retval ERROR_FILE_NOT_FOUND The file wasn't found
    \retval E_ACCESSDENIED The file wasn't able to be opened
    \retval E_HANDLE The reader handle is already open
    \retval E_OUTOFMEMORY no more memory is available
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnOpenProfile(
    /*in*/ const wchar_t* pPath,
    /*out*/ ReaderHandle** pReaderHandle);

/** This function will open an aggregated profile data file as the default
    data set of the reader.

    The file extension should be ".tbp" or ".ebp".

    \note This function is deprecated. Please use fnOpenProfile instead.

    \ingroup datafiles
    @param[in] pFileName The profile data file of interest
    @param[out] pReaderHandle The handle to use for retrieving the data
    \return The success of opening the profile
    \retval S_OK Success
    \retval E_INVALIDARG pFileName is not a valid pointer
    \retval ERROR_FILE_NOT_FOUND The file wasn't found
    \retval E_ACCESSDENIED The file wasn't able to be opened
    \retval E_OUTOFMEMORY no more memory is available
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnOpenAggregatedProfile(
    /*in*/ wchar_t* pFileName,
    /*out*/ ReaderHandle** pReaderHandle);

/** Releases all resources appropriately.  Note that after this call, the
    reader handle will not be valid.
    \ingroup datafiles
    @param[in,out] pReaderHandle The handle to close
    \return The success of closing the profile
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle
    \retval E_ACCESSDENIED There is data currently being aggregated, and that
    function must be canceled first.
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnCloseProfile(
    /*in*/ ReaderHandle** pReaderHandle);

/** This function will use the JIT data files from the specified directory
    during the data aggregation.  If the directory is NULL, the aggregation
    will use the temporary JIT data directory used by the profile agents.

    \note The JIT data files are generated by the profile agents, and must be
    synchronized with the profile data.

    \ingroup datafiles
    @param[in] pJitDirName The JIT data file directory of interest, NULL to use
    the default
    @param[in] pReaderHandle The handle to use for retrieving the data
    \return The success of setting the directory to JIT data files of interest
    \retval S_OK Success
    \retval E_INVALIDARG pJitDirName does not contain a valid file name, or
    pReaderHandle was not an open handle
    \retval E_ACCESSDENIED The directory could not be opened or was not
    readable
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnSetJitDir(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pJitDirName);

/** This function will clear the temporary JIT data files from the directory
    used by the profile agents.

    \note The JIT data files are generated by the profile agents, and must be
    synchronized with the profile data.  If the JIT data files have not been
    saved by \ref fnAggregateDataSets, old profiles may lose the ability to
    accurately report the JIT profile information.

    \ingroup datafiles
    \return The success of opening the profile
    \retval S_OK Success
    \retval E_ACCESSDENIED The directory could not be cleared
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnClearTempJitDir();

/** This function will retrieve the system cpu family and model numbers

    \ingroup datafiles
    @param[in] pReaderHandle The open reader handle
    @param[out] pCpuFamily The family of the system cpu(s)
    @param[out] pCpuModel The model of the system cpu(s)
    @param[out] pCoreCount (Optional) The count of cores on the system
    \return The success of getting the cpu information
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle is not an open handle, or pCpuFamily or
    pCpuModel are invalid
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetCpuInfo(
    /*in*/ ReaderHandle* pReaderHandle,
    /*out*/ unsigned int* pCpuFamily,
    /*out*/ unsigned int* pCpuModel,
    /*out*/ unsigned int* pCoreCount = NULL);

/****************************************************************************/

/** This will return the time mark of the start of the profile
    \ingroup timemarks
    @param[in] pReaderHandle The open reader handle
    @param[out] pTimeMark The time mark at the start of the profile
    \return The success of getting the time mark
    \retval S_OK Success
    \retval E_FAIL The profile data was aggregated, and this is not available
    \retval E_INVALIDARG pReaderHandle was not an open handle or pTimeMark was
    an invalid pointer
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetStartTimeMark(
    /*in*/ ReaderHandle* pReaderHandle,
    /*out*/ CPA_TIME* pTimeMark);

/** This will return the time mark of the end of the profile
    \ingroup timemarks
    @param[in] pReaderHandle The open reader handle
    @param[out] pTimeMark The time mark at the end of the profile
    \return The success of getting the time mark
    \retval S_OK Success
    \retval E_FAIL The profile data was aggregated, and this is not available
    \retval E_INVALIDARG pReaderHandle was not an open handle or pTimeMark was
    an invalid pointer
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetEndTimeMark(
    /*in*/ ReaderHandle* pReaderHandle,
    /*out*/ CPA_TIME* pTimeMark);

/****************************************************************************/

/** \struct ProfileDataSetInterval
    \brief A data set interval is defined by two time marks, [start, end).
    \ingroup datasets

    A data set is defined by one or more data set intervals.  Any intervals
    that end before the start of the profile data or start after the end of the
    profile data will be ignored.

    You can generate the time marks either through the \ref
    fnGetCurrentTimeMark or with the Windows time functions like
    CoDosDateTimeToFileTime().
*/
struct ProfileDataSetInterval
{
    /** interval start */
    CPA_TIME start;
    /** interval end */
    CPA_TIME end;
};

/** This will define a new data set by the intervals.
    If a data set is intended to be the repository of merged data sets, the
    array can be empty.
    \ingroup datasets

    @param[in] pReaderHandle The open reader handle
    @param[in] pIntervals The array of intervals that defines the set
    @param[in] count The number of intervals in the array
    @param[in] pDataSetName The data set name for later retrieval
    \return The success of adding the data set
    \retval S_OK Success
    \retval E_ABORT a previous data set has the same name
    \retval E_FAIL The profile data was aggregated, and this is not available
    \retval E_INVALIDARG pReaderHandle was not an open handle
    \retval E_OUTOFMEMORY no more memory is available
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnAddDataSet(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ ProfileDataSetInterval* pIntervals,
    /*in*/ unsigned int count,
    /*in*/ const wchar_t* pDataSetName);

/** This will provide a count of the current data sets

    \ingroup datasets
    @param[in] pReaderHandle The open reader handle
    @param[out] pCount The count of data sets
    \return The success of getting the data set information
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, or a NULL
    pointer was provided
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetDataSetCount(
    /*in*/ ReaderHandle* pReaderHandle,
    /*out*/unsigned int* pCount);

/** This will fill an array with the data set names

    \note If the reader handle closes, the data set names will no longer be valid
    \ingroup datasets
    @param[in] pReaderHandle The open reader handle
    @param[in] maxSize The maximum number of data set names to return
    @param[out] ppDataSets The array of names of data sets
    \return The success of getting the data sets
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, a NULL
    pointer was provided, or the maximum size was zero
    \retval E_OUTOFMEMORY The specified size is less than the number of
    data sets, or no memory could be allocated for the data set names
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnListDataSets(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ unsigned int maxSize,
    /*out*/ wchar_t** ppDataSets);

/** This will remove the named data set.  The default data set cannot be
    removed.
    \ingroup datasets
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName The data set name to remove.  Cannot be NULL for
        the default data set.
    \return The success of removing the data set
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle or an invalid
    data set name was provided
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnRemoveDataSet(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName);

/** This will fill the data sets with data, based on the data set interval
    definitions. You can iteratively define and process the data sets.  If a
    data set has already been aggregated, it will not be processed again.

    If another thread is monitoring the progress, and the variable
    pPercentComplete is provided, it will have the current amount complete.
    If pPercentComplete is NULL, there is no way to track the progress.

    If no data sets are defined, then the default data set of the entire
    profile will be used.  A data set can be empty of data.

    If pJitDataDirectory is not NULL, the appropriate JIT data files that
    contain data from the profile will be copied to the specified directory.
    The function \ref fnWriteSetToFile will automatically copy the java data
    files for that data set.

    \ingroup datasets
    @param[in] pReaderHandle The open reader handle
    @param[in] pCancel a way to cancel the processing from another thread.
    @param[in] pJitDataDirectory The directory, if any, to write the JIT data
    files to.
    @param[out] pPercentComplete a way to track the progress of the processing

    \return The success of processing
    \retval S_OK Success
    \retval S_FALSE You cancelled the processing or the reader handle was
    opened for an aggregated file
    \retval E_INVALIDARG pReaderHandle was not an open handle or
    pJitDataDirectory was not writable
    \retval E_ACCESSDENIED the jitDataDirectory could not be created
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnAggregateDataSets(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ bool* pCancel,
    /*in*/ wchar_t* pJitDataDirectory,
    /*out*/ float* pPercentComplete);

/** This will write the named data set to a file, including all necessary
    call-stack and JIT data files in the same directory.  No filters will be
    applied to the written data.

    \ingroup datasets
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName The data set name to write
    @param[in] pFileName The file name to write to
    @param[out] pPercentComplete an optional way to track the progress of the writing
    \return The success of removing the data set
    \retval S_OK Success
    \retval E_PENDING The profile data was not yet aggregated
    \retval E_INVALIDARG pReaderHandle was not an open handle, or an invalid
    data set name was provided
    \retval E_ACCESSDENIED the access to the path was denied
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnWriteSetToFile(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ const wchar_t* pDataSetName,
    /*in*/ const wchar_t* pFileName,
    /*in*/ PfnProgressBarCallback pfnProgressBarCallback,
    /*in*/ const wchar_t* pSearchPath = NULL,
    /*in*/ const wchar_t* pServerList = NULL,
    /*in*/ const wchar_t* pCachePath = NULL);

/** This will append the aggregated source data set into the aggregated
    destination data set.

    \note The default data set cannot be the destination data set.

    \ingroup datasets
    @param[in] pReaderHandle The open reader handle
    @param[in] pDestinationDataSet The destination data set which will hold the
        aggregated data, cannot be NULL
    @param[in] pSourceDataSet The source data set to append
    \return The success of appending the data set
    \retval S_OK Success
    \retval E_PENDING The profile data was not yet aggregated
    \retval E_INVALIDARG pReaderHandle was not an open handle, or an invalid
    data set name was provided
    \retval E_OUTOFMEMORY no more memory is available
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnAppendDataSets(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ const wchar_t* pDestinationDataSet,
    /*in*/ const wchar_t* pSourceDataSet);

/****************************************************************************/

/** This function will retrieve the available core mask from the profile.

    \ingroup rules
    @param[in] pReaderHandle The open reader handle
    @param[out] pCoreMask The core mask of the profile
    \return The success of getting the available core mask
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle is not an open handle, or pCoreMask is
    invalid
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetAvailableCoreData(
    /*in*/ ReaderHandle* pReaderHandle,
    /*out*/ gtUInt64* pCoreMask);

/** This function will show only data from the masked cores, so a value of 3
    will show values from cores 0 and 1 (1 << 0 | 1 << 1).  By default all
    cores are shown.

    \ingroup rules
    @param[in] pReaderHandle The open reader handle
    @param[in] coreMask The core data to show.  It must be greater than 0.
    \return The success of setting the rule
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, or an invalid
    core mask was given
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnSetRuleCoreData(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ gtUInt64 coreMask = -1);

/** This will limit data returned to only the selected processes.

    By default, data for all processes are returned.  Use \ref fnResetRules to clear
    the setting. The caller must provide an accurate count.

    \ingroup rules
    @param[in] pReaderHandle The open reader handle
    @param[in] count The number of process IDs in the array
    @param[in] pProcessIdList The array of processes ids to return data about
    \return The success of setting the rule
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, an empty
    list was given, or count was 0
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnSetRuleForProcesses(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ unsigned int count,
    /*in*/ unsigned int* pProcessIdList);

/** This will limit instruction data returned by \ref fnGetInstructionData
    to only the selected threads.

    By default, all threads are returned. Use \ref fnResetRules to clear
    the setting.

    \ingroup rules
    @param[in] pReaderHandle The open reader handle
    @param[in] count The number of process ids in the array
    @param[in] pThreadIdList The array of thread ids to return data about
    \return The success of setting the rule
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, or an invalid
    list was given
    \retval E_ACCESSDENIED The count was larger than the array
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnSetRuleForThreads(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ unsigned int count,
    /*in*/ unsigned int* pThreadIdList);

/** This will reset all rules back to their defaults.

    \ingroup rules
    @param[in] pReaderHandle The open reader handle
    \return The success of resetting the rules
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnResetRules(
    /*in*/ ReaderHandle* pReaderHandle);

/****************************************************************************/

/** This will get the count of the performance events used to get the sample
    data returned in the other fnGetXData functions.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[out] pCount The count of the performance events
    \return The success of retrieving the data event count
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, or
        pCount was NULL
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetDataEventCount(
    /*in*/ ReaderHandle* pReaderHandle,
    /*out*/ unsigned int* pCount);


/** This will get the performance events used to get the sample data returned
    in the other fnGetXData functions.

    If you want the human-readable performance event labels, you can optionally
    provide a pointer to pDataLabels.  If you want the performance event
    sampling interval, for normalization purposes, you can optionally provide
    a pointer to pSampItvls.

    \note At least one of the arrays must be provided for output.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] maxSize The maximum number of events return in appropriate arrays
    @param[out] pPerformanceEvents The array of performance events, in the same
        order as the data values
    @param[out] ppDataLabels The optional array of human-readable names of
        performance events, in the same order as the data values
    @param[out] pSampIntvls The optional array of sample intervals of performance
        events, in the same order as the data values
    \return The success of retrieving the data events
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, or
        pPerformanceEvents was NULL
    \retval E_OUTOFMEMORY There were more events than the arrays could hold
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetDataEvents(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ unsigned int maxSize,
    /*out*/ gtUInt64* pPerformanceEvents,
    /*out*/ wchar_t** ppDataLabels = NULL,
    /*out*/ gtUInt64* pSampIntvls = NULL);

/** \struct SampleDatumKey
    \brief This structure is a key for the sample count data in \ref SampleData

    \ingroup data
*/
struct SampleDatumKey
{
    /** Which core is the value for */
    int core;
    /** Which performance event is the value for */
    gtUInt64 event;
};

/** This function has to imply that !(a < b) is (a >= b), for the sorting to
    work
*/
inline bool operator< (const SampleDatumKey& temp1, const SampleDatumKey& temp2)
{
    if (temp1.core < temp2.core)
    {
        return true;
    }
    else if (temp1.core > temp2.core)
    {
        return false;
    }
    else if (temp1.event < temp2.event)
    {
        return true;
    }
    else
    {
        return false;
    }
};


/** \struct SampleData
    \brief This structure holds the data
    \ingroup data
*/
struct SampleData
{
    /** How many data are available in the arrays */
    unsigned int count;
    /** The array of keys of the data */
    SampleDatumKey* keyArray;
    /** The array of data */
    gtUInt64* dataArray;
    /** Constructor */
    SampleData() { keyArray = NULL; dataArray = NULL; count = 0;}
};


/** This enum represents the type of module.
    \ingroup data
*/typedef enum
{
    InvalidModType, /**< An invalid module */
    UnmanagedModType, /**< A regular, unmanaged application or library */
    JavaModType, /**< JIT-generated module information */
    ManagedModType, /**< A managed application or library */
    KernelModType, /**< Kernel module> */
    UnknownModType /**< An unknown module */
} ModuleType;

/** \struct ModuleDataType
    \brief This structure holds all the data for module-level samples.
    \ingroup data
*/
struct ModuleDataType
{
    /** The path of the module */
    wchar_t* path;
    /** The process id of the samples, may vary based on rules */
    unsigned int processId;
    /** Whether the module is 64-bit */
    bool is64Bit;
    /** The sample data that occurred in the module */
    SampleData data;
    ModuleDataType() { path = NULL; }
};

/** This will get the count of the system-wide list of modules and data for
    the given data set, depending on the rules set. If NULL is given for the
    data set, then the default will be used.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[out] pCount The count of the modules
    \return The success of retrieving the data event count
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, the
        pDataSetName was invalid, or pCount was NULL
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetModuleDataCount(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*out*/ unsigned int* pCount);


/** This function will retrieve the system-wide list of modules and data for
    the given data set, depending on the rules set. If NULL is given for the
    data set, then the default will be used. The list to describe the values
    in the data field can be obtained with the function call fnGetDataEvents.

    You may have different list items with the same module name, but a
    different process id.  The list is sorted first by module name, then by
    process id.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[in] maxSize The maximum number of module data to return in the array
    @param[out] pSystemData The array of data
    \return The success of retrieving the data
    \retval S_OK Success
    \retval E_PENDING The profile data was not yet aggregated
    \retval E_INVALIDARG pReaderHandle was not an open handle, the pDataSetName
        was invalid, or pSystemData was NULL
    \retval E_OUTOFMEMORY there was more data than the array can hold
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetModuleData(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*in*/ unsigned int maxSize,
    /*out*/ ModuleDataType* pSystemData);

/** This will get the count of the system-wide list of processes and data for
    the given data set, depending on the rules set. If NULL is given for the
    data set, then the default will be used.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[out] pCount The count of the processes
    \return The success of retrieving the data event count
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, or
        pCount was NULL
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetProcessDataCount(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*out*/ unsigned int* pCount);

/** This function will retrieve the system-wide array of processes and data for
    the given data set, depending on the rules set. If NULL is given for the
    data set, then the default will be used.  The array to describe the values
    in the data field can be obtained with the function call fnGetDataEvents.

    The returned array is sorted by ascending pid

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[in] maxSize The maximum number of module data to return in the array
    @param[out] pProcessData The list of data
    \return The success of retrieving the data
    \retval S_OK Success
    \retval E_PENDING The profile data was not yet aggregated
    \retval E_INVALIDARG pReaderHandle was not an open handle, or
    pSystemData was NULL
    \retval E_OUTOFMEMORY there was more data than the array can hold
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetProcessData(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*in*/ unsigned int maxSize,
    /*out*/ ModuleDataType* pProcessData);

/** \struct InstructionDataType
    \brief This structure holds all the data for instruction-level samples.
    \ingroup data
*/
struct InstructionDataType
{
    /** The address of the sampled instruction.
    \note that IBS fetch samples addresses may fall between actual instructions
    */
    gtUInt64 address;
    /** The process id of the samples, may vary based on rules */
    unsigned int processId;
    /** The thread id of the samples, may vary based on rules */
    unsigned int threadId;
    /** The load address of the jit function only provided for JIT samples */
    gtUInt64 jitAddress;
    /** The JIT generated function name, only provided for JIT samples */
    wchar_t* pJitFunctionName;
    /** The JIT generated data file name, only provided for JIT samples */
    wchar_t* pJitDataFile;
    /** The sample data that occurred in the module */
    SampleData data;
    InstructionDataType()
    {
        pJitFunctionName = NULL;
        pJitDataFile = NULL;
    }
} ;

/** The less than function for the \ref InstructionDataType
*/
inline bool operator< (const InstructionDataType& temp1,
                       const InstructionDataType& temp2)
{
    if (temp1.address < temp2.address)
    {
        return true;
    }
    else if (temp1.processId > temp2.processId)
    {
        return false;
    }
    else if (temp1.threadId < temp2.threadId)
    {
        return true;
    }
    else
    {
        return false;
    }
};

/** The equality function for the \ref InstructionDataType
*/
inline bool operator== (const InstructionDataType& temp1,
                        const InstructionDataType& temp2)
{
    if (temp1.address != temp2.address)
    {
        return false;
    }
    else if (temp1.processId != temp2.processId)
    {
        return false;
    }
    else if (temp1.threadId != temp2.threadId)
    {
        return false;
    }
    else
    {
        return true;
    }
};

/** This will get the count of instruction addresses and data for the given
    module in the given data set, depending on the rules set. If NULL is given
    for the data set, then the default will be used.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[in] modulePath The module of interest
    @param[out] pCount The count of the processes
    \return The success of retrieving the data event count
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle, pCount was NULL,
    or modulePath was not a valid module for the data set
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetInstructionDataCount(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*in*/ wchar_t* modulePath,
    /*out*/ unsigned int* pCount);

/** This function will retrieve the array of instruction addresses and data for
    the given module in the given data set, depending on the rules set. If
    NULL is given for the data set, then the default will be used.  The array
    to describe the values in the data field can be obtained with the function
    call fnGetDataEvents.

    You may have different array items with the same address, but a different
    thread id or process id.  The array is sorted first by address, then process
    id, then thread id.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[in] modulePath The module of interest
    @param[in] maxSize The maximum number of module data to return in the array
    @param[out] pInstructionData The array of data
    @param[out] pModuleLoadAddress The module load address
    @param[out] pModuleType The type of the module data
    \return The success of retrieving the data
    \retval S_OK Success
    \retval E_PENDING The profile data was not yet aggregated
    \retval E_INVALIDARG pReaderHandle was not an open handle, pInstructionData was
    NULL, or modulePath was not a valid module for the data set
    \retval E_OUTOFMEMORY there was more data than the array can hold
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetInstructionData(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*in*/ wchar_t* modulePath,
    /*in*/ unsigned int maxSize,
    /*out*/ InstructionDataType* pInstructionData,
    /*out*/ gtUInt64* pModuleLoadAddress = NULL,
    /*out*/ ModuleType* pModuleType = NULL);

/** \struct JITDataType
    \brief This structure retrieves JIT information for the given address.
    \ingroup data
*/
typedef struct
{
    /** The native code bytes for the instruction at the address */
    const gtUByte* pNativeCodeBytes;
    /** The Java virtual machine reported source file name */
    wchar_t* sourceFileName;
    /** The Java virtual machine reported line number */
    int lineNumber;
} JITDataType ;

/** This function will retrieve the saved JIT data given the address and JNC
    file name.

    \note If the jitType is ManagedModType, you will need to obtain the source file
    and line numbers through the standard symbolic information.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[in] offset The offset into the jit function to report on
    @param[in] pJncDataFile The jnc file of JIT data
    @param[in] jitType Whether the JIT information is from Java or is managed
    @param[out] pJitData The JIT data
    \return The success of retrieving the data
    \retval S_OK Success
    \retval E_PENDING The profile data was not yet aggregated
    \retval E_ACCESSDENIED The jnc file wasn't found
    \retval E_INVALIDARG pReaderHandle was not an open handle, pJncDataFile was
    NULL, the address was not found in the provided jnc file, the jnc file was
    not found, or the type was incorrect
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetJitData(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*in*/ gtUInt64 offset,
    /*in*/ wchar_t* pJncDataFile,
    /*in*/ ModuleType jitType,
    /*out*/ JITDataType* pJitData);

/** \struct RawDataType
    \brief This structure holds all the data for one profile sample.

    If the module of a sample is unknown, the full sample address will be
    given.  If the module is known, the offset into the module will be given.

    \note An IBS sample will have multiple data for one sample.

    \ingroup data
*/
typedef struct
{
    /** Sample time mark */
    CPA_TIME timeMark;
    /** The path of the module */
    wchar_t* path;
    /** The load address of the module */
    gtUInt64 loadAddress;
    /** The size of the module */
    gtUInt64 moduleSize;
    /** Sample address */
    gtUInt64 address;
    /** What type of module is it */
    ModuleType type;
    /** The process id of the sample */
    unsigned int processId;
    /** The thread id of the sample */
    unsigned int threadId;
    /** The JIT generated function name, only provided for JIT samples */
    wchar_t* pJitFunctionName;
    /** The JIT generated data file name, only provided for JIT samples */
    wchar_t* pJitDataFile;
    /** Valid if the IBS ops sample data contained a branch target address */
    gtUInt64 ibsOpBranchAddress;
    /** Valid if the IBS ops sample data contained a data cache linear address */
    gtUInt64 ibsOpDcLinearAddress;
    /** Valid if the IBS ops sample data contained a data cache physical address */
    gtUInt64 ibsOpDcPhysicalAddress;
    /** The sample data that occurred in the module */
    SampleData data;
} RawDataType ;

/** This function will get the first raw (un-aggregated) record from the
    profile intervals defined by the data set, depending on the rules set. If
    NULL is given for the data set, then the default will be used.  This
    function is only valid for profile files opened with \ref fnOpenProfile.

    fnGetFirstRawRecord needs to be called before \ref fnGetNextRawRecord will
    return valid data.  Call-stack data will not be available from this
    function.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName which data set to retrieve data from
    @param[out] pData the first raw sample data
    \return The success of retrieving the data
    \retval S_OK Success
    \retval S_FALSE There are no more records available, or the data file was
    not finished being written to.
    \retval E_ACCESSDENIED The un-aggregated profile data was not available
    \retval E_INVALIDARG pReaderHandle was not an open handle, pDataSetName
        was not a valid name, or pData was NULL
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetFirstRawRecord(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ wchar_t* pDataSetName,
    /*out*/ RawDataType* pData);

/** This function will get the next raw (un-aggregated) record from the
    profile intervals defined by the data set used in the \ref
    fnGetFirstRawRecord call, depending on the rules set. This function is
    only valid for profile files opened with \ref fnOpenProfile.

    \ref fnGetFirstRawRecord needs to be called before fnGetNextRawRecord will
    return valid data.  Call-stack data will not be available from this
    function.

    \ingroup data
    @param[in] pReaderHandle The open reader handle
    @param[out] pData the next raw sample data
    @param[out] pPercentComplete the optional percentage complete

    \return The success of retrieving the data
    \retval S_OK Success
    \retval S_FALSE There are no more records available, 100% complete
    \retval E_ACCESSDENIED The un-aggregated profile data was not available
    \retval E_POINTER \ref fnGetFirstRawRecord has not been called yet
    \retval E_INVALIDARG pReaderHandle was not an open handle or pData was NULL
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnGetNextRawRecord(
    /*in*/ ReaderHandle* pReaderHandle,
    /*out*/ RawDataType* pData,
    /*out*/ float* pPercentComplete);

CP_TRANS_API HRESULT fnMigrateEBPToDB(
    /*in*/ const osFilePath& ebpFilePath);

//TODO:
//  fnGetCssData();
//  fnGetCluData();
#endif  // _CPUPROFILEDATATRANSLATION_H_
