//==============================================================================
// Copyright (c) 2015 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file
/// \brief  This file is the main agent file for the HSA PMC module
//==============================================================================

#include <hsa_api_trace.h>

#include <cstdlib>
#include <iostream>

#include "Logger.h"
#include "FileUtils.h"
#include "GlobalSettings.h"

#include "HSAPMCInterceptionTable1_0.h"
#include "HSAAgentUtils.h"

#include "HSAGPAProfiler.h"

#include "AutoGenerated/HSAPMCInterception.h"

#include "../CLOccupancyAgent/CLOccupancyInfoManager.h"

extern "C" DLL_PUBLIC void amdtCodeXLStopProfiling()
{
    HSAGPAProfiler::Instance()->EnableProfiling(false);
}

extern "C" DLL_PUBLIC void amdtCodeXLResumeProfiling()
{
    HSAGPAProfiler::Instance()->EnableProfiling(true);
}

extern "C" bool DLL_PUBLIC OnLoad(void* pTable, uint64_t runtimeVersion, uint64_t failedToolCount, const char* const* pFailedToolNames)
{
#ifdef _DEBUG
    FileUtils::CheckForDebuggerAttach();
#endif

    std::string strLogFile = FileUtils::GetDefaultOutputPath() + "hsapmcagent.log";
    LogFileInitialize(strLogFile.c_str());

    if (!CheckRuntimeToolsLibLoaded(runtimeVersion, failedToolCount, pFailedToolNames))
    {
        std::cout << "CodeXL GPU Profiler could not be enabled. Version mismatch between HSA runtime and " << HSA_RUNTIME_TOOLS_LIB << std::endl;
        return false;
    }

    std::cout << "CodeXL GPU Profiler " << GPUPROFILER_BACKEND_VERSION_STRING << " is enabled\n";

    if (0 == runtimeVersion)
    {
        InitHSAAPIInterceptPMC1_0(reinterpret_cast<ApiTable1_0*>(pTable));
    }
#ifdef FUTURE_ROCR_VERSION
    else
    {
        InitHSAAPIInterceptPMC(reinterpret_cast<HsaApiTable*>(pTable));
    }
#endif

    Parameters params;
    FileUtils::GetParametersFromFile(params);

    GlobalSettings::GetInstance()->m_params = params;
    OccupancyInfoManager::Instance()->SetOutputFile(params.m_strOutputFile);
    OccupancyInfoEntry::m_cListSeparator = params.m_cOutputSeparator;

    std::string strError;

    if (!HSAGPAProfiler::Instance()->Init(GlobalSettings::GetInstance()->m_params, strError))
    {
        Log(logERROR, "Error loading HSA PMC Profiler. Error: %s\n", strError.c_str());
        return false;
    }

    return true;
}

extern "C" void DLL_PUBLIC OnUnload()
{
    // wait for all remaining sessions to end.
    // This is a safety net -- there shouldn't be any remaining sessions in well-behaved apps
    HSAGPAProfiler::Instance()->WaitForCompletedSessions();

    if (GlobalSettings::GetInstance()->m_params.m_bKernelOccupancy)
    {
        OccupancyInfoManager::Instance()->SaveToOccupancyFile();
    }

    DoneHSAAPIInterceptPMC();
}

