/*
 * The MIT License
 *
 * Copyright (c) 2016-17 Samsung Electronics Co., Ltd. All Rights Reserved
 * For conditions of distribution and use, see the accompanying COPYING file.
 *
 */

//
// Autogenerated by ./src/generate_dcapi_strings.py
//

#include <assert.h>

#include "dcapi_strings.h"

static const char * Unknown = "Unknown";

const char * DCAPI_RunString(eRun v)
{
  switch(v)
  {
    case rRunning: return "Running"; break;
    case rPaused: return "Paused"; break;
    case rStopped: return "Stopped"; break;
    default: return Unknown; break;
   }
}
eRun DCAPI_RunFromString(const char* s)
{
  if(0 == strcmp(s, "Running"))
    return rRunning;
  else if(0 == strcmp(s, "Paused"))
    return rPaused;
  else if(0 == strcmp(s, "Stopped"))
    return rStopped;
  else
  {
    assert(!"Unknown enum");
    return rRunning;
  }
}
const char * DCAPI_CategoryString(eCategory v)
{
  switch(v)
  {
    case cHigh: return "High"; break;
    case cSoftware: return "Software"; break;
    case cDriver: return "Driver"; break;
    case cCounter: return "Counter"; break;
    case cMaxCategory: return "MaxCategory"; break;
    default: return Unknown; break;
   }
}
eCategory DCAPI_CategoryFromString(const char* s)
{
  if(0 == strcmp(s, "High"))
    return cHigh;
  else if(0 == strcmp(s, "Software"))
    return cSoftware;
  else if(0 == strcmp(s, "Driver"))
    return cDriver;
  else if(0 == strcmp(s, "Counter"))
    return cCounter;
  else if(0 == strcmp(s, "MaxCategory"))
    return cMaxCategory;
  else
  {
    assert(!"Unknown enum");
    return cHigh;
  }
}
const char * DCAPI_TypeString(eType v)
{
  switch(v)
  {
    case tInteger: return "Integer"; break;
    case tFloat: return "Float"; break;
    case tPercentage: return "Percentage"; break;
    default: return Unknown; break;
   }
}
eType DCAPI_TypeFromString(const char* s)
{
  if(0 == strcmp(s, "Integer"))
    return tInteger;
  else if(0 == strcmp(s, "Float"))
    return tFloat;
  else if(0 == strcmp(s, "Percentage"))
    return tPercentage;
  else
  {
    assert(!"Unknown enum");
    return tInteger;
  }
}
const char * DCAPI_UnitString(eUnit v)
{
  switch(v)
  {
    case uPowerWatts: return "PowerWatts"; break;
    case uPowerKJ: return "PowerKJ"; break;
    case uCurrent: return "Current"; break;
    case uFrequency: return "Frequency"; break;
    case uLoad: return "Load"; break;
    case uTempC: return "Centigrade"; break;
    case umAmps: return "MicroAmps"; break;
    case uFPS: return "FPS"; break;
    default: return Unknown; break;
   }
}
eUnit DCAPI_UnitFromString(const char* s)
{
  if(0 == strcmp(s, "PowerWatts"))
    return uPowerWatts;
  else if(0 == strcmp(s, "PowerKJ"))
    return uPowerKJ;
  else if(0 == strcmp(s, "Current"))
    return uCurrent;
  else if(0 == strcmp(s, "Frequency"))
    return uFrequency;
  else if(0 == strcmp(s, "Load"))
    return uLoad;
  else if(0 == strcmp(s, "Centigrade"))
    return uTempC;
  else if(0 == strcmp(s, "MicroAmps"))
    return umAmps;
  else if(0 == strcmp(s, "FPS"))
    return uFPS;
  else
  {
    assert(!"Unknown enum");
    return uPowerWatts;
  }
}
const char * DCAPI_ErrorString(eError v)
{
  switch(v)
  {
    case DCAPI_INITIALIZATION_FAILURE: return "DCAPI_INITIALIZATION_FAILURE"; break;
    case DCAPI_COLLECTION_NOT_ACTIVE: return "DCAPI_COLLECTION_NOT_ACTIVE"; break;
    case DCAPI_COLLECTION_ALREADY_ACTIVE: return "DCAPI_COLLECTION_ALREADY_ACTIVE"; break;
    case DCAPI_INVALID_PTR_ARGUMENT: return "DCAPI_INVALID_PTR_ARGUMENT"; break;
    case DCAPI_BAD_COUNTERSET_ID: return "DCAPI_BAD_COUNTERSET_ID"; break;
    case DCAPI_BAD_COUNTER_INDEX: return "DCAPI_BAD_COUNTER_INDEX"; break;
    case DCAPI_COLLECTION_INACTIVE: return "DCAPI_COLLECTION_INACTIVE"; break;
    case DCAPI_NO_COUNTERS_DEFINED: return "DCAPI_NO_COUNTERS_DEFINED"; break;
    case DCAPI_SUCCESS: return "DCAPI_SUCCESS"; break;
    default: return Unknown; break;
   }
}
eError DCAPI_ErrorFromString(const char* s)
{
  if(0 == strcmp(s, "DCAPI_INITIALIZATION_FAILURE"))
    return DCAPI_INITIALIZATION_FAILURE;
  else if(0 == strcmp(s, "DCAPI_COLLECTION_NOT_ACTIVE"))
    return DCAPI_COLLECTION_NOT_ACTIVE;
  else if(0 == strcmp(s, "DCAPI_COLLECTION_ALREADY_ACTIVE"))
    return DCAPI_COLLECTION_ALREADY_ACTIVE;
  else if(0 == strcmp(s, "DCAPI_INVALID_PTR_ARGUMENT"))
    return DCAPI_INVALID_PTR_ARGUMENT;
  else if(0 == strcmp(s, "DCAPI_BAD_COUNTERSET_ID"))
    return DCAPI_BAD_COUNTERSET_ID;
  else if(0 == strcmp(s, "DCAPI_BAD_COUNTER_INDEX"))
    return DCAPI_BAD_COUNTER_INDEX;
  else if(0 == strcmp(s, "DCAPI_COLLECTION_INACTIVE"))
    return DCAPI_COLLECTION_INACTIVE;
  else if(0 == strcmp(s, "DCAPI_NO_COUNTERS_DEFINED"))
    return DCAPI_NO_COUNTERS_DEFINED;
  else if(0 == strcmp(s, "DCAPI_SUCCESS"))
    return DCAPI_SUCCESS;
  else
  {
    assert(!"Unknown enum");
    return DCAPI_INITIALIZATION_FAILURE;
  }
}
const char * DCAPI_EnableString(eEnable v)
{
  switch(v)
  {
    case DCAPI_ENABLE: return "DCAPI_ENABLE"; break;
    case DCAPI_DISABLE: return "DCAPI_DISABLE"; break;
    default: return Unknown; break;
   }
}
eEnable DCAPI_EnableFromString(const char* s)
{
  if(0 == strcmp(s, "DCAPI_ENABLE"))
    return DCAPI_ENABLE;
  else if(0 == strcmp(s, "DCAPI_DISABLE"))
    return DCAPI_DISABLE;
  else
  {
    assert(!"Unknown enum");
    return DCAPI_ENABLE;
  }
}